"""
OpenCngsm v3.3 - Penetration Testing Framework
Framework automatizado para testes de seguran√ßa

Features:
- Testes de prompt injection
- Testes de rate limiting
- Testes de seguran√ßa de credenciais
- Testes de sandbox isolation
- Relat√≥rios automatizados
- CI/CD integration
"""
import logging
import asyncio
from pathlib import Path
from typing import List, Dict, Any, Optional
from datetime import datetime
from dataclasses import dataclass, field
from enum import Enum

logger = logging.getLogger(__name__)


class TestStatus(Enum):
    """Status de teste"""
    PASSED = "passed"
    FAILED = "failed"
    SKIPPED = "skipped"
    ERROR = "error"


@dataclass
class TestResult:
    """
    Resultado de um teste individual
    
    Attributes:
        test_name: Nome do teste
        status: Status do teste
        message: Mensagem descritiva
        details: Detalhes adicionais
        duration: Dura√ß√£o em segundos
    """
    test_name: str
    status: TestStatus
    message: str
    details: Optional[Dict[str, Any]] = None
    duration: float = 0.0
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class TestSuite:
    """
    Suite de testes
    
    Attributes:
        name: Nome da suite
        results: Lista de resultados
        total_duration: Dura√ß√£o total
    """
    name: str
    results: List[TestResult] = field(default_factory=list)
    total_duration: float = 0.0
    
    def add_result(self, result: TestResult):
        """Adiciona resultado"""
        self.results.append(result)
        self.total_duration += result.duration
    
    def get_stats(self) -> Dict[str, int]:
        """Retorna estat√≠sticas"""
        stats = {
            'total': len(self.results),
            'passed': 0,
            'failed': 0,
            'skipped': 0,
            'error': 0
        }
        
        for result in self.results:
            stats[result.status.value] += 1
        
        return stats
    
    def success_rate(self) -> float:
        """Retorna taxa de sucesso"""
        stats = self.get_stats()
        if stats['total'] == 0:
            return 0.0
        return (stats['passed'] / stats['total']) * 100


class PenetrationTestFramework:
    """
    Framework de testes de penetra√ß√£o
    
    Features:
    - Execu√ß√£o de testes automatizados
    - Gera√ß√£o de relat√≥rios
    - Valida√ß√£o de seguran√ßa
    
    Example:
        framework = PenetrationTestFramework()
        suite = await framework.run_all_tests()
        framework.generate_report(suite)
    """
    
    def __init__(self, config_dir: Optional[Path] = None):
        """
        Initialize Penetration Test Framework
        
        Args:
            config_dir: Diret√≥rio de configura√ß√£o (opcional)
        """
        self.config_dir = config_dir or Path("/tmp/opencngsm_pentest")
        self.config_dir.mkdir(parents=True, exist_ok=True)
        
        logger.info("‚úÖ Penetration Test Framework inicializado")
    
    async def run_all_tests(self) -> TestSuite:
        """
        Executa todos os testes de seguran√ßa
        
        Returns:
            TestSuite com todos os resultados
        """
        logger.info("üß™ Iniciando testes de penetra√ß√£o...")
        
        suite = TestSuite(name="OpenCngsm Security Tests")
        
        # Importar m√≥dulos de teste
        from tests.security.test_prompt_injection import PromptInjectionTests
        from tests.security.test_rate_limiting import RateLimitingTests
        from tests.security.test_credential_security import CredentialSecurityTests
        from tests.security.test_sandbox_isolation import SandboxIsolationTests
        
        # Executar testes
        test_classes = [
            PromptInjectionTests(),
            RateLimitingTests(),
            CredentialSecurityTests(),
            SandboxIsolationTests(),
        ]
        
        for test_class in test_classes:
            results = await test_class.run_all()
            for result in results:
                suite.add_result(result)
        
        logger.info(f"‚úÖ Testes conclu√≠dos: {len(suite.results)} testes")
        
        return suite
    
    def generate_report(self, suite: TestSuite, output_file: Optional[Path] = None):
        """
        Gera relat√≥rio de testes
        
        Args:
            suite: Suite de testes
            output_file: Arquivo de sa√≠da (opcional)
        """
        stats = suite.get_stats()
        success_rate = suite.success_rate()
        
        # Gerar relat√≥rio em texto
        report = f"""
{'=' * 80}
üß™ PENETRATION TEST REPORT
{'=' * 80}

Suite: {suite.name}
Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Duration: {suite.total_duration:.2f}s

{'‚îÄ' * 80}
SUMMARY
{'‚îÄ' * 80}

Total Tests: {stats['total']}
‚úÖ Passed: {stats['passed']}
‚ùå Failed: {stats['failed']}
‚è≠Ô∏è Skipped: {stats['skipped']}
‚ö†Ô∏è Error: {stats['error']}

Success Rate: {success_rate:.1f}%

{'‚îÄ' * 80}
DETAILED RESULTS
{'‚îÄ' * 80}

"""
        
        # Adicionar resultados detalhados
        for i, result in enumerate(suite.results, 1):
            status_icon = {
                TestStatus.PASSED: "‚úÖ",
                TestStatus.FAILED: "‚ùå",
                TestStatus.SKIPPED: "‚è≠Ô∏è",
                TestStatus.ERROR: "‚ö†Ô∏è"
            }.get(result.status, "‚ùì")
            
            report += f"{i}. {status_icon} {result.test_name}\n"
            report += f"   Status: {result.status.value}\n"
            report += f"   Message: {result.message}\n"
            report += f"   Duration: {result.duration:.3f}s\n"
            
            if result.details:
                report += f"   Details: {result.details}\n"
            
            report += "\n"
        
        # Conclus√£o
        report += f"{'‚îÄ' * 80}\n"
        report += f"CONCLUSION\n"
        report += f"{'‚îÄ' * 80}\n\n"
        
        if success_rate >= 95:
            report += "‚úÖ EXCELLENT: Security posture is strong (‚â•95% success rate)\n"
        elif success_rate >= 80:
            report += "‚ö†Ô∏è GOOD: Security is acceptable but needs improvement (‚â•80% success rate)\n"
        elif success_rate >= 60:
            report += "‚ö†Ô∏è WARNING: Security has significant gaps (‚â•60% success rate)\n"
        else:
            report += "‚ùå CRITICAL: Security is inadequate (<60% success rate)\n"
        
        report += f"\n{'=' * 80}\n"
        
        # Salvar relat√≥rio
        if output_file is None:
            output_file = self.config_dir / f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        
        output_file.write_text(report, encoding='utf-8')
        logger.info(f"üìÑ Relat√≥rio salvo: {output_file}")
        
        # Exibir no console
        print(report)
        
        return report
    
    def generate_json_report(self, suite: TestSuite, output_file: Optional[Path] = None):
        """
        Gera relat√≥rio em formato JSON
        
        Args:
            suite: Suite de testes
            output_file: Arquivo de sa√≠da (opcional)
        """
        import json
        
        report = {
            'suite_name': suite.name,
            'timestamp': datetime.now().isoformat(),
            'total_duration': suite.total_duration,
            'stats': suite.get_stats(),
            'success_rate': suite.success_rate(),
            'results': [
                {
                    'test_name': r.test_name,
                    'status': r.status.value,
                    'message': r.message,
                    'details': r.details,
                    'duration': r.duration,
                    'timestamp': r.timestamp.isoformat()
                }
                for r in suite.results
            ]
        }
        
        if output_file is None:
            output_file = self.config_dir / f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        output_file.write_text(json.dumps(report, indent=2), encoding='utf-8')
        logger.info(f"üìÑ Relat√≥rio JSON salvo: {output_file}")
        
        return report


# Base class for test suites
class BaseTestSuite:
    """Classe base para suites de teste"""
    
    def __init__(self, name: str):
        self.name = name
        self.results = []
    
    async def run_all(self) -> List[TestResult]:
        """Executa todos os testes"""
        raise NotImplementedError
    
    def _create_result(
        self,
        test_name: str,
        status: TestStatus,
        message: str,
        details: Optional[Dict] = None,
        duration: float = 0.0
    ) -> TestResult:
        """Cria resultado de teste"""
        return TestResult(
            test_name=test_name,
            status=status,
            message=message,
            details=details,
            duration=duration
        )


# Example usage
if __name__ == "__main__":
    async def main():
        framework = PenetrationTestFramework()
        
        print("=" * 80)
        print("üß™ Penetration Test Framework - Demo")
        print("=" * 80)
        print()
        
        # Criar suite de exemplo
        suite = TestSuite(name="Demo Tests")
        
        # Adicionar resultados de exemplo
        suite.add_result(TestResult(
            test_name="Test 1: Prompt Injection Detection",
            status=TestStatus.PASSED,
            message="All attack vectors blocked",
            duration=0.123
        ))
        
        suite.add_result(TestResult(
            test_name="Test 2: Rate Limiting",
            status=TestStatus.PASSED,
            message="Rate limit enforced correctly",
            duration=0.456
        ))
        
        suite.add_result(TestResult(
            test_name="Test 3: Credential Encryption",
            status=TestStatus.PASSED,
            message="Credentials properly encrypted",
            duration=0.789
        ))
        
        # Gerar relat√≥rio
        framework.generate_report(suite)
        
        # Gerar relat√≥rio JSON
        framework.generate_json_report(suite)
        
        print(f"\n‚úÖ Relat√≥rios gerados em: {framework.config_dir}")
    
    asyncio.run(main())
